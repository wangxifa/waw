<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Webpack 进阶篇 | 汪啊汪</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/waw/favicon.ico">
    <meta name="description" content="为中华之崛起而读书。">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/waw/assets/css/0.styles.335629c4.css" as="style"><link rel="preload" href="/waw/assets/js/app.4506181e.js" as="script"><link rel="preload" href="/waw/assets/js/3.c812e0bc.js" as="script"><link rel="preload" href="/waw/assets/js/1.24e126b5.js" as="script"><link rel="preload" href="/waw/assets/js/14.1e185c4c.js" as="script"><link rel="prefetch" href="/waw/assets/js/10.0e44a592.js"><link rel="prefetch" href="/waw/assets/js/11.be3a3d1a.js"><link rel="prefetch" href="/waw/assets/js/12.c46c65fa.js"><link rel="prefetch" href="/waw/assets/js/13.5a0b7946.js"><link rel="prefetch" href="/waw/assets/js/15.f0f00b2c.js"><link rel="prefetch" href="/waw/assets/js/16.b483f425.js"><link rel="prefetch" href="/waw/assets/js/17.f7d2eef0.js"><link rel="prefetch" href="/waw/assets/js/18.fcb9def5.js"><link rel="prefetch" href="/waw/assets/js/4.2bc02c3a.js"><link rel="prefetch" href="/waw/assets/js/5.d60b660b.js"><link rel="prefetch" href="/waw/assets/js/6.c072e86c.js"><link rel="prefetch" href="/waw/assets/js/7.dca0726b.js"><link rel="prefetch" href="/waw/assets/js/8.3c3ad491.js"><link rel="prefetch" href="/waw/assets/js/9.d07898f1.js">
    <link rel="stylesheet" href="/waw/assets/css/0.styles.335629c4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-2d5f533b><div data-v-2d5f533b><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-2d5f533b data-v-2d5f533b><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-2d5f533b data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>汪啊汪</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>清风</span>
            
          <!---->
          2020
        </a></span></div></div> <div class="hide" data-v-2d5f533b><header class="navbar" data-v-2d5f533b><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/waw/" class="home-link router-link-active"><!----> <span class="site-name">汪啊汪</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/waw/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/waw/categories/Webpack/" class="nav-link"><i class="iconfont undefined"></i>
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/waw/categories/article/" class="nav-link"><i class="iconfont undefined"></i>
  article
</a></li></ul></div></div><div class="nav-item"><a href="/waw/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/waw/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/wangxifa" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-2d5f533b></div> <aside class="sidebar" data-v-2d5f533b><div class="personal-info-wrapper" data-v-ca798c94 data-v-2d5f533b><img src="/waw/avatar.png" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    清风
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>3</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>2</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="/waw/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/waw/categories/Webpack/" class="nav-link"><i class="iconfont undefined"></i>
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/waw/categories/article/" class="nav-link"><i class="iconfont undefined"></i>
  article
</a></li></ul></div></div><div class="nav-item"><a href="/waw/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/waw/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/wangxifa" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Webpack 进阶篇</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>清风</span>
            
          <!---->
          2020
        </a></span></div></div> <div data-v-2d5f533b><main class="page"><div class="page-title" style="display:none;"><h1 class="title">Webpack 进阶篇</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>清风</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2020-11-25</span></i> <i class="iconfont reco-eye" data-v-3b7f5bdf><span id="/waw/blogs/webpack/2020/20201125.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-3b7f5bdf><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>Webpack</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d973f26dd8d348b68bf7cfc5427744e9~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>  接着基础篇，进阶篇将从 webpack.config.js 文件入手，将配置内容展开，一步步介绍 webpack 是如何工作。将从以下五个方面由浅入深展示 webpack：</p> <div style="font-size:16px;word-spacing:2px;letter-spacing:2px;font-family:'Helvetica Neue', Helvetica, 'Hiragino Sans GB', 'Microsoft YaHei', Arial, sans-serif;background-image:linear-gradient(90deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%), linear-gradient(360deg, rgba(50, 0, 0, 0.05) 3%, rgba(0, 0, 0, 0) 3%);background-size:20px 20px;"><div><p><strong>入口(entry)</strong></p> <p><strong>出口(output)</strong></p> <p><strong>预处理器(loader)</strong></p> <p><strong>插件(plugins)</strong></p> <p><strong>模式(mode)</strong></p> <p>在开始之前先问自己一个问题：<strong>webpack 源文件从哪里来，组装完成之后的产出又要交给谁？</strong></p> <hr> <h2 id="入口-出口"><a href="#入口-出口" class="header-anchor">#</a> 入口&amp;出口</h2> <h3 id="资源处理"><a href="#资源处理" class="header-anchor">#</a> 资源处理</h3> <p>  webapck 故事的开始从指定一个或多个入口开始，这是故事的起源，如果 webpack 是一棵树，那么入口就相当于一棵树的根。事实上也确实如此，webapck 会从入口文件开始检索，并将具有依赖关系的模块生成一颗依赖树，最终生成一个 chunk(字面意思是代码块，在 webpack 中可以理解成被抽象和包装过后的一些模块)。由 chunk 得到的打包产物我们一般称之为 bundle,它们关系如下：</p> <p><strong>entry -&gt; module -&gt; bundle</strong></p> <h3 id="入口"><a href="#入口" class="header-anchor">#</a> 入口</h3> <p>在 webpack 通过 context，entry 两个配置项共同决定入口文件的位置。配置入口的时，实际上做了两件事情：</p> <ol><li>确定入口位置</li> <li>定义 chunk name</li></ol> <h4 id="context"><a href="#context" class="header-anchor">#</a> context</h4> <blockquote><p>基本目录，一个绝对路径，用于从配置中解析入口点和加载器
context 可以理解成资源入口的路径前缀，在配置时必须使用绝对路径的形式，而且它必须是字符串。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>const path = require('path');

module.exports = {
  context: path.resolve(__dirname, './src')
  enrty: './compontens/index.js
};
module.exports = {
  context: path.resolve(__dirname, './src/compontens')
  enrty: './index.js
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这两个等价，主要是为了让 entry 更加简洁。context 可以省略～</p> <h4 id="entry"><a href="#entry" class="header-anchor">#</a> entry</h4> <p>与 context 必须是字符串不同，entry 可以是字符串、数组、对象、函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>string [string] object = { &lt;key&gt; string | [string] | object = { import string | [string], dependOn string | [string], filename string }} (function() =&gt; string | [string] | object = { &lt;key&gt; string | [string] } | object = { import string | [string], dependOn string | [string], filename string })
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol><li>字符串</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>module.exports = {
  entry: &quot;./src/index.js&quot;,
  output: {
    filename: &quot;./bundle.js&quot;
  },
  mode: &quot;development&quot;,
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol start="2"><li>数组类型
说明：传数组作用是将多个资源文件预先合并，在打包时 webpack 会将数组中的最后一个元素作为实际的入口路径。</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>module.exports = {
  entry: ['react', './src/index.js'],
  output: {
    filename: &quot;./bundle.js&quot;
  },
  mode: &quot;development&quot;,
};
等同于
module.exports = {
  entry: './src/index.js',
  output: {
    filename: &quot;./bundle.js&quot;
  },
  mode: &quot;development&quot;,
};

index.js
import 'react',
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>3.对象类型
如果想要定义多入口，则必须使用对象类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>module.exports = {
  entry: {
  	index: './src/index.js',
    lib: './src/lib.js',
  },
};

对象值也可以是数组
module.exports = {
  entry: {
  	index: ['react', './src/index.js'],,
    lib: './src/lib.js',
  },
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ol start="4"><li>函数类型
函数类型支持异步操作，动态加载</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>module.exports = {
  entry: () =&gt; ({
  	index: ['react', './src/index.js'],,
    lib: './src/lib.js',
  }),
};

异步
module.exports = {
  entry: () =&gt; new Promise((resolve) =&gt; {
  	setTimeout(() =&gt; {
    	resolve('./src/index.js')
    })
  }),
};
动态加载
module.exports = {
  entry() {
  	// 从外部源（远程服务器，文件系统内容或数据库）获取实际条目
    return fetchPathsFromSomeExternalSource();
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h4 id="vendor"><a href="#vendor" class="header-anchor">#</a> vendor</h4> <p>当项目体积越来越大时，一旦代码更新，即便很小改动。用户都要下载整个资源文件，对性能很不友好，为了解决这个问题，我们可以使用提取<strong>vendor</strong>方法。vendor 是供应商对意思，在 webpack 中一般指的是第三方模块集中打包而产生对 bundle。提取 vendor</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>module.exports = {
  entry: {
  	index: './src/index.js',
    vendor: ['react','react-dom','react-redux'],
  },
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们进行了 vendor 提取，那么问题来了，我们并没有为 vendor 设置入口路径，webpack 要如何打包呢？这时候我们可以使用<strong>optimization.splitChunks</strong>,将 index 和 vendor 中的公共模块提取出来。通过这样的配置，index 产生的 bundle 将只包含业务模块，而其依赖的第三方模块将被抽取出来形成一个新的 bundel，这样就达到了我们提取 vendor 的目的。而由于这部分不会经常变动，因此可以有效的利用客户端缓存，在后续请求页面时会加快整体的渲染速度。</p> <h3 id="出口"><a href="#出口" class="header-anchor">#</a> 出口</h3> <p>  出口的配置项多达十余种，这里只详细将几种常用的配置项。先看简单的例子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    filename: 'my-first-webpack.bundle.js',
    path: path.resolve(__dirname, 'dist'),
    publicPath: '/dist/',
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="filename"><a href="#filename" class="header-anchor">#</a> filename</h4> <p>filename 作用是输出资源的文件名，其形式是字符串，看简单例子如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>output: {
    filename: 'bundle.js',
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当然它还可以是文件路径：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>output: {
    filename: './dist/bundle.js',
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们也可以为每个 bundle 指定不同的名字，webpack 使用类似模版语言动态的生成文件名：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>output: {
    filename: '[name].js',
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果要控制客户端缓存，最好加上[chunkhash],因为每个 chunk 所产生的 chunkhash 只与自身内容有关，单个内容的改变不会影响其他资源，可以精准的让客户端缓存得到更新。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>output: {
    filename: '[name]@[chunkhash].js',
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="path"><a href="#path" class="header-anchor">#</a> path</h4> <p>path 指定资源输出位置，它的值必须是绝对路径。看例子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    filename: 'my-first-webpack.bundle.js',
    path: path.resolve(__dirname, 'dist'),
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>例子中将输出路径设置为 dist 目录，webpack4 之后，打包路径默认设置成 dist 目录</p> <h4 id="publicpath"><a href="#publicpath" class="header-anchor">#</a> publicPath</h4> <p>publicPath 容易与 path 混淆</p> <p>path 是指定<strong>文件输出位置</strong>
而 publicPath 是指定<strong>资源的请求位置</strong></p> <h3 id="实例"><a href="#实例" class="header-anchor">#</a> 实例</h3> <h4 id="单入口"><a href="#单入口" class="header-anchor">#</a> 单入口</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const path = require('path');

module.exports = {
  entry: './src/app.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'), // webpack4之后默认配置可省略
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="多入口"><a href="#多入口" class="header-anchor">#</a> 多入口</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const path = require('path');

module.exports = {
  entry: {
  	pageA: './src/pageA.js',
    pageB: './src/pageB.js'
  },
  output: {
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist'), // webpack4之后默认配置可省略
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="预处理器-loader"><a href="#预处理器-loader" class="header-anchor">#</a> 预处理器 (loader)</h2> <p>  回顾之前的内容，我们讨论的都是如何进行 javascript 的打包，但是，一个项目不可能只要 javascript 文件，项目中的 html，css, less, scss, 图片，字体，模版等等 webpack 是怎么处理的呢？webpack 是如何对预编译同一管理的呢？
loader，它赋予了 webpack 处理不同资源类型的能力，大大丰富了 webpack 的可扩展性</p> <p>  对于 webpack 来说，一切都是模块，我们可以像加载 js 一样去加载 css，可以在同一个 js 文件中去维护 js 和 css 文件。模块是具有高内聚及可复用性的结构，通过 webapck<strong>一切皆模块</strong>的思想，我们可以将这些特性应用到每一种静态资源上面。那么我们一起来揭开 loader 的面纱吧～</p> <h3 id="什么是-loader"><a href="#什么是-loader" class="header-anchor">#</a> 什么是 loader</h3> <p>在正式开始前先让我们了解一下 loader 是什么？其实每个 loader 在本质上都是一个函数。在 webpack4 之前，函数的输入输出都必须为字符串；在 webpack4 之后，loader 也同时支持抽象语法树（AST）的传递，通过这样的方法来减少重复代码的解析。</p> <p>output = loader(input)</p> <p>这里的 input 可能是工程文件的字符串，也可能是上一个 loader 转化的结果，loader 是链式的</p> <p>output = loaderA（loaderB（loaderC（input）））；</p> <p>让我们看下 loader 源码结构</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>module.exports = function loader (content, map, meta) {
    var callback = this.async();
    var result = handle(content, map, meta);

    callback(
    	null,
        result.content, // 转换后的内容
        result.map, // 转换后的 source-map
        result.meta, // 转换后的AST
    )
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>可以看出 loader 本身就是一个函数，在该函数中对接受到的内容进行转换。</p> <h3 id="从打包一个-css-文件开始"><a href="#从打包一个-css-文件开始" class="header-anchor">#</a> 从打包一个 css 文件开始</h3> <p>我们在 src 目录下添加 main.css 文件，目录结构如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> └─ webpackDemo ························ sample root dir
    ├── src ·································· source dir
+   │   └── main.css ························· main styles
	│	└── index.js ························· index js
    ├── package.json ························· package file
    └── webpack.config.js ···················· webpack config file
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>main.css</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/* ./src/main.css */
body {
  margin: 0 auto;
  padding: 100px;
  background: yellowgreen;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>然后在 index.js 中引入 css</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import HelloWorld from &quot;./hello-world&quot;;
import &quot;./main.css&quot;;

document.write(&quot;My first webpack app &lt;br /&gt;&quot;);
HelloWorld();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>配置完成过后回到命令行终端再次运行 Webpack 打包命令，此时你会发现命令行报出了一个模块解析错误，如下所示：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d50126110ae45818132bde283214130~tplv-k3u1fbpfcp-watermark.image" alt="">
webapck 无法处理 css 语法，所以抛出来一个错误，并且提示需要一个合适的 loader 来处理这种文件：
需要的是一个可以加载 CSS 模块的 Loader，最常用到的是 css-loader。我们需要通过 npm 先去安装这个 Loader，然后在配置文件中添加对应的配置，具体操作和配置如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ npm install css-loader --save-dev
# or yarn add css-loader --dev

module.exports = {
  entry: &quot;./src/index.js&quot;,
  output: {
    filename: &quot;./bundle.js&quot;
  },
  module: {
    rules: [
      {
        test: /\.css$/, // 根据打包过程中所遇到文件路径匹配是否使用这个 loader
        use: &quot;css-loader&quot; // 指定具体的 loader
      }
    ]
  },
  mode: &quot;development&quot;,
  devServer: {
    publicPath: &quot;./dist&quot; // 在后面会说publicPath是什么意思
  }
};

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>在配置对象的 module 属性中添加一个 rules 数组。这个数组就是我们针对资源模块的加载规则配置，其中的每个规则对象都需要设置两个属性：</p> <ul><li><p>首先是 test 属性，它是一个正则表达式，用来匹配打包过程中所遇到文件路径，这里我们是以 .css 结尾；</p></li> <li><p>然后是 use 属性，它用来指定匹配到的文件需要使用的 loader，这里用到的是 css-loader。</p></li></ul> <p>配置完成之后在执行打包命令就不会出错了,流程如下：</p> <p>css -&gt; css-loader -&gt; webpack -&gt; bundle</p> <p>但是这时候你会发现虽然打包成功来，但是 css 样式并没有生效，这是因为 css-loader 的作用仅仅是处理 css 的各种加载语法。如果要让 css 起作用，还需要 style-loader 来把样式插入页面，要 css-loader 和 style-loader 联合起来使用
同样的，我们先安装 style-loader</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>$ npm install style-loader --save-dev
# or yarn add style-loader --dev

module.exports = {
  entry: &quot;./src/index.js&quot;,
  output: {
    filename: &quot;./bundle.js&quot;
  },
  module: {
    rules: [
      {
        test: /\.css$/, // 根据打包过程中所遇到文件路径匹配是否使用这个 loader
        // 对同一个模块使用多个 loader，注意顺序
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;]
      }
    ]
  },
  mode: &quot;development&quot;,
  devServer: {
    publicPath: &quot;./dist&quot; // 在后面会说publicPath是什么意思
  }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>配置完成之后，再次回到命令行重新打包，此时 bundle.js 文件中会额外多出两个模块。style-loader 的作用总结一句话就是，将 css-loader 中所加载到的所有样式模块，通过创建 style 标签的方式添加到页面上。</p> <blockquote><p>别忘记重新 npm run build!</p></blockquote> <p>这样样式就会生效来，可以看到 style 标签，包含 css 样式，这样我们就完成来从 js 文件加载 css 文件的配置</p> <h3 id="exclude-include"><a href="#exclude-include" class="header-anchor">#</a> exclude &amp; include</h3> <p>这里介绍一下 loader 的两个相关配置
exclude 的含义是，所以被正则匹配到的模块都被排除在改规则外，例如</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>rules: [
  {
    test: /\.css$/, // 根据打包过程中所遇到文件路径匹配是否使用这个 loader
    // 对同一个模块使用多个 loader，注意顺序
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;],
    exclude: /node_modules/,
  }
]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>node_modules 就被排除在外来，exclude 一般在配置时是必加的，不然会拖慢整体的打包速度</p> <p>include 代表的则是该规则只对正则匹配到对模块生效。例如我们将 include 设置为源码 src 目录，自然也就排除了 node_modules。
如果同时存在，exclude 优先级更高。</p> <h3 id="常用-loader"><a href="#常用-loader" class="header-anchor">#</a> 常用 loader</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>babel-loader https://webpack.js.org/loaders/babel-loader
html-loader  https://webpack.js.org/loaders/html-loader
file-loader	 https://webpack.js.org/loaders/file-loader
url-loader	 https://webpack.js.org/loaders/url-loader
style-loader https://webpack.js.org/loaders/style-loader
css-loader	 https://webpack.js.org/loaders/css-loader
sass-loader	 https://webpack.js.org/loaders/sass-loader
postcss-loader	https://webpack.js.org/loaders/postcss-loader
eslint-loader	https://github.com/webpack-contrib/eslint-loader
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="自定义-loader"><a href="#自定义-loader" class="header-anchor">#</a> 自定义 loader</h3> <p>有时候现有 loader 不能满足我们的要求，这时候需要我们对其进行修改，现在让我们从头到位实现一个 loader。
这里我的需求是开发一个可以加载 markdown 文件的加载器，以便可以在代码中直接导入 md 文件。我们都应该知道 markdown 一般是需要转换为 html 之后再呈现到页面上的，所以我希望导入 md 文件后，直接得到 markdown 转换后的 html 字符串，</p> <p>每个 Webpack 的 Loader 都需要导出一个函数，这个函数就是我们这个 Loader 对资源的处理过程，它的输入就是加载到的资源文件内容，输出就是我们加工后的结果。我们通过 source 参数接收输入，通过返回值输出。</p> <h4 id="第一步"><a href="#第一步" class="header-anchor">#</a> 第一步</h4> <p>引入 loader 有两种形式，npm 安装，直接引入；</p> <p>这里直接在项目根目录下创建一个 markdown-loader.js 文件，完成后你可以把这个模块发布到 npm 上作为一个独立的模块使用。
了解了 Loader 大致的工作机制过后，我们再回到 markdown-loader.js 中，接着完成我的需求。这里需要安装一个能够将 Markdown 解析为 HTML 的模块，叫作 marked。
然后通过 marked 去解析我们的 markdown 语法，解析完的结果就是一段 HTML 字符串。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// ./markdown-loader.js
const marked = require(&quot;marked&quot;);
module.exports = source =&gt; {
  // 1. 将 markdown 转换为 html 字符串
  const html = marked(source);
  // html =&gt; '&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;this is a markdown file.&lt;/p&gt;'
  // 2. 将 html 字符串拼接为一段导出字符串的 JS 代码
  const code = `module.exports = ${JSON.stringify(html)}`;
  return code;
  // code =&gt; 'export default &quot;&lt;h1&gt;About&lt;/h1&gt;&lt;p&gt;this is a markdown file.&lt;/p&gt;&quot;'
};

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="第二步"><a href="#第二步" class="header-anchor">#</a> 第二步</h4> <p>创建 md 文件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!-- ./src/markdown.md --&gt;
# markdown
this is a markdown file.

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在 index.js 文件中引入 md 文件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>import markdown from &quot;./markdown.md&quot;;
document.write(markdown);

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>接下来修改配置，引入 loader</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>module.exports = {
  entry: &quot;./src/index.js&quot;,
  output: {
    filename: &quot;./bundle.js&quot;
  },
  module: {
    rules: [
      {
        test: /\.css$/, // 根据打包过程中所遇到文件路径匹配是否使用这个 loader
        // 对同一个模块使用多个 loader，注意顺序
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;]
      },
      {
        test: /\.md$/,
        // 直接使用相对路径
        use: &quot;./markdown-loader.js&quot;
      }
    ]
  },
  mode: &quot;development&quot;,
  devServer: {
    publicPath: &quot;./dist&quot; // 在后面会说publicPath是什么意思
  }
};

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h4 id="第三步"><a href="#第三步" class="header-anchor">#</a> 第三步</h4> <p>执行打包命令，并打开浏览器预览</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm run build
npm run dev
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以看到正确显示出了 markdowm 语法：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e511d18207b4bc8a21ea3bca3f20f39~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <h4 id="多个-loader-的配合"><a href="#多个-loader-的配合" class="header-anchor">#</a> 多个 Loader 的配合</h4> <p>我们还可以尝试一下刚刚说的第二种思路，就是在我们这个 markdown-loader 中直接返回 HTML 字符串，然后交给下一个 Loader 处理。这就涉及多个 Loader 相互配合工作的情况了。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// ./markdown-loader.js
const marked = require('marked')
module.exports = source =&gt; {
  // 1. 将 markdown 转换为 html 字符串
  const html = marked(source)
  return html
}

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>然后我们再安装一个处理 HTML 的 Loader，叫作 html-loader，代码如下所示：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install html-loader --save-dev

module.exports = {
  entry: &quot;./src/index.js&quot;,
  output: {
    filename: &quot;./bundle.js&quot;
  },
  module: {
    rules: [
      {
        test: /\.css$/, // 根据打包过程中所遇到文件路径匹配是否使用这个 loader
        // 对同一个模块使用多个 loader，注意顺序
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;]
      },
      {
        test: /\.md$/,
        // 直接使用相对路径
        use: [&quot;html-loader&quot;, &quot;./markdown-loader&quot;]
      }
    ]
  },
  mode: &quot;development&quot;,
  devServer: {
    publicPath: &quot;./dist&quot; // 在后面会说publicPath是什么意思
  }
};

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>安装完成再进行打包，编译，你会发现代码仍然能够正常运行。</p> <p>loader 是 webpack 的核心功能之一，有了 loader，webpack 才可以去加载你想加载的资源。</p> <h2 id="插件-plugins"><a href="#插件-plugins" class="header-anchor">#</a> 插件(plugins)</h2> <p>Loader 是负责完成项目中各种各样资源模块的加载，从而实现整体项目的模块化，而 Plugin 则是用来解决项目中除了资源模块打包以外的其他自动化工作，所以说 Plugin 的能力范围更广，用途自然也就更多。
那我们能用插件做什么？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>实现自动在打包之前清除 dist 目录（上次的打包结果）；
自动生成应用所需要的 HTML 文件；
根据不同环境为代码注入类似 API 地址这种可能变化的部分；
拷贝不需要参与打包的资源文件到输出目录；
压缩 Webpack 打包完成后输出的文件；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>现在让我们走进常用插件</p> <h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="header-anchor">#</a> clean-webpack-plugin</h3> <p>你可能已经发现，Webpack 每次打包的结果都是直接覆盖到 dist 目录。而在打包之前，dist 目录中就可能已经存入了一些在上一次打包操作时遗留的文件，当我们再次打包时，只能覆盖掉同名文件，而那些已经移除的资源文件就会一直累积在里面，最终导致部署上线时出现多余文件，这显然非常不合理。</p> <p>更为合理的做法就是在每次完整打包之前，自动清理 dist 目录，这样每次打包过后，dist 目录中就只会存在那些必要的文件。</p> <h4 id="安装"><a href="#安装" class="header-anchor">#</a> 安装</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install clean-webpack-plugin --save-dev
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>安装完成之后在 webpack.config.js 引入文件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;);

module.exports = {
  entry: &quot;./src/index.js&quot;,
  output: {
    filename: &quot;./bundle.js&quot;
  },
  module: {
    rules: [
      {
        test: /\.css$/, // 根据打包过程中所遇到文件路径匹配是否使用这个 loader
        // 对同一个模块使用多个 loader，注意顺序
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;]
      },
      {
        test: /\.md$/,
        // 直接使用相对路径
        use: [&quot;html-loader&quot;, &quot;./markdown-loader&quot;]
      }
    ]
  },
  plugins: [new CleanWebpackPlugin()],
  mode: &quot;development&quot;,
  devServer: {
    publicPath: &quot;./dist&quot; // 在后面会说publicPath是什么意思
  }
};

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>OK，现在让我们测试一下，重新打包看是否删除 dist 文件，你可以在 bundle 加些内容，看打包之后是否清空。</p> <h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="header-anchor">#</a> html-webpack-plugin</h3> <p>项目发布时，我们需要同时发布根目录下的 HTML 文件和 dist 目录中所有的打包结果，非常麻烦，而且上线过后还要确保 HTML 代码中的资源文件路径是正确的。
如果打包结果输出的目录或者文件名称发生变化，那 HTML 代码中所对应的 script 标签也需要我们手动修改路径。</p> <p>解决这两个问题最好的办法就是让 Webpack 在打包的同时，自动生成对应的 HTML 文件，让 HTML 文件也参与到整个项目的构建过程。这样的话，在构建过程中，Webpack 就可以自动将打包的 bundle 文件引入到页面中。</p> <h4 id="安装-2"><a href="#安装-2" class="header-anchor">#</a> 安装</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install html-webpack-plugin --save-dev
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>安装完成之后在 webpack.config.js 引入文件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const HtmlWebpackPlugin = require('html-webpack-plugin')
plugins: [
  new CleanWebpackPlugin(),
  new HtmlWebpackPlugin()
]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>最后我们回到命令行终端，再次运行打包命令，此时打包过程中就会自动生成一个 index.html 文件到 dist 目录。我们找到这个文件，可以看到文件中的内容就是一段使用了 bundle.js 的空白 HTML，具体结果如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Webpack App&lt;/title&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt;
  &lt;body&gt;
  &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>我们还可以对 HtmlWebpackPlugin 进行配置:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      title: &quot;Webpack Plugin Sample&quot;,
      meta: {
        viewport: &quot;width=device-width&quot;
      }
    })
  ],
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="自定义-plugins"><a href="#自定义-plugins" class="header-anchor">#</a> 自定义 plugins</h3> <p>前面我们简单的实现了一个 loader，知道了 loader 的基本原理：</p> <ul><li>Loader 导出一个函数</li> <li>经过函数内部对参数源文件的处理返回一个字符串</li></ul> <p>那么我们如何编写一个 plugins 呢？</p> <p><strong>钩子机制</strong></p> <p>Webpack 的插件机制就是我们在软件开发中最常见的钩子机制
钩子机制也特别容易理解，它有点类似于 Web 中的事件。或者说 react,vue 中的生命周期。
为了便于插件的扩展，Webpack 几乎在每一个环节都埋下了一个钩子。这样我们在开发插件的时候，通过往这些不同节点上挂载不同的任务，就可以轻松扩展 Webpack 的能力。</p> <p>具体有哪些预先定义好的钩子，我们可以参考官方文档的 API：</p> <p><a href="https://webpack.js.org/api/compiler-hooks/" target="_blank" rel="noopener noreferrer">Compiler Hooks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://webpack.js.org/api/compilation-hooks/" target="_blank" rel="noopener noreferrer">Compilation Hooks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://webpack.js.org/api/parser/" target="_blank" rel="noopener noreferrer">JavascriptParser Hooks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>感兴趣的可以去了解一些，现在让我们实现能够自动清除 Webpack 打包结果中的注释的插件。</p> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8166586a2a64475781a43aad5f27612a~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <h4 id="第一步-2"><a href="#第一步-2" class="header-anchor">#</a> 第一步</h4> <p>在根目录新建 remove-comments-plugin.js 文件</p> <p>Webpack 要求我们的插件必须是<strong>一个函数或者是一个包含 apply 方法的对象</strong>，一般我们都会定义一个类型，在这个类型中定义 apply 方法。然后在使用时，再通过这个类型来创建一个实例对象去使用这个插件。
这里定义一个 RemoveCommentsPlugin 类型，然后在这个类型中定义一个 apply 方法，这个方法会在 Webpack 启动时被调用，它接收一个 compiler 对象参数，这个对象是 Webpack 工作过程中最核心的对象，里面包含了我们此次构建的所有配置信息，我们就是通过这个对象去注册钩子函数，具体代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// ./remove-comments-plugin.js
class RemoveCommentsPlugin {
  apply (compiler) {
    console.log('RemoveCommentsPlugin 启动')
    // compiler =&gt; 包含了我们此次构建的所有配置信息
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="第二步-2"><a href="#第二步-2" class="header-anchor">#</a> 第二步</h4> <p>如何删除打包文件的注释呢？是不是应该先等打包完成之后再去执行这个钩子函数？
所以我们使用一个叫作 emit 的钩子，这个钩子会在 Webpack 即将向输出目录输出文件时执行。
通过 compiler 对象的 hooks 属性访问到 emit 钩子，再通过 tap 方法注册一个钩子函数，这个方法接收两个参数：</p> <ul><li>第一个是插件的名称，我们这里的插件名称是 RemoveCommentsPlugin；</li> <li>第二个是要挂载到这个钩子上的函数；</li></ul> <p>我们先 for in 打印看一下每一个文件的名称</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// ./remove-comments-plugin.js

class RemoveCommentsPlugin {
  apply(compiler) {
    console.log(&quot;MyPlugin 启动&quot;);

    compiler.hooks.emit.tap(&quot;RemoveCommentsPlugin&quot;, compilation =&gt; {
      // compilation =&gt; 可以理解为此次打包的上下文

      for (const name in compilation.assets) {
        console.log(name); // 输出文件名称
      }
    });
  }
}
module.exports = RemoveCommentsPlugin;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在 weback.config.js 引入插件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const RemoveCommentsPlugin = require(&quot;./remove-comments-plugin&quot;);

plugins: [
    new RemoveCommentsPlugin(),
  ],
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>运行之后可以看到正确执行了我们插件文件内容
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae175e1945fb4fbc8cabc10a0b7b5add~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <h4 id="第三步-2"><a href="#第三步-2" class="header-anchor">#</a> 第三步</h4> <p>能够拿到文件名和文件内容后，我们回到代码中。这里需要先判断文件名是不是以 .js 结尾，因为 Webpack 打包还有可能输出别的文件，而我们的需求只需要处理 JS 文件。</p> <p>我们将文件内容得到，再通过正则替换的方式移除掉代码中的注释，最后覆盖掉 compilation.assets 中对应的对象，在覆盖的对象中，我们同样暴露一个 source 方法用来返回新的内容。另外还需要再暴露一个 size 方法，用来返回内容大小，这是 Webpack 内部要求的格式，具体代码如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// ./remove-comments-plugin.js
class RemoveCommentsPlugin {
  apply(compiler) {
    compiler.hooks.emit.tap(&quot;RemoveCommentsPlugin&quot;, compilation =&gt; {
      // compilation =&gt; 可以理解为此次打包的上下文

      for (const name in compilation.assets) {
        if (name.endsWith(&quot;.js&quot;)) {
          const contents = compilation.assets[name].source();

          const noComments = contents.replace(/\/\*{2,}\/\s?/g, &quot;&quot;);

          compilation.assets[name] = {
            source: () =&gt; noComments,

            size: () =&gt; noComments.length
          };
        }
      }
    });
  }
}
module.exports = RemoveCommentsPlugin;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>运行命令，查看 bundle
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96403cab445c45f9b2b24fb8c6ec927b~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <p>清除成功，通过自己实现插件我们发现关键点就是使用生命周期钩子中挂载任务函数去完成一个插件点实现。</p> <h2 id="模式-mode"><a href="#模式-mode" class="header-anchor">#</a> 模式(mode)</h2> <p>通过选择 development, production 或 none 之中的一个，来设置 mode 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 production。
传递 mode 的方式
第一种，在 webpack.config.js 中设置 mode 值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>module.exports = {
  mode: 'production'
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>或者从 CLI 参数中传递：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>webpack --mode=development
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>如果没有设置，webpack 会给 mode 的默认值设置为 production
我们可以通过 mode 进行开发环境的配置，来设置不同环境的相关配置。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>进阶篇从五个核心配置属性展开，介绍了 webpack 基本配置。webpack 属性不可能全部介绍完，更重要的是对它们对理解，知道其实现的基本原理，举一反三，能够做到心中有数～</p> <h2 id="本文章的编写参考了"><a href="#本文章的编写参考了" class="header-anchor">#</a> 本文章的编写参考了</h2> <p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=88#/detail/pc?id=2260" target="_blank" rel="noopener noreferrer">Webpack 原理与实践<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://book.douban.com/subject/34430881/" target="_blank" rel="noopener noreferrer">webapck 实战<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="相关系列"><a href="#相关系列" class="header-anchor">#</a> 相关系列</h2> <p><a href="https://juejin.cn/post/6897817213534502920" target="_blank" rel="noopener noreferrer">Webpack 基础篇<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div></div></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="kanbanniang" data-v-5775ee02><div class="banniang-container" style="display:;" data-v-5775ee02><div class="messageBox" style="right:68px;bottom:190px;display:none;" data-v-5775ee02>
      欢迎来到 汪啊汪
    </div> <div class="operation" style="right:90px;bottom:40px;display:none;" data-v-5775ee02><i class="kbnfont kbn-ban-home ban-home" data-v-5775ee02></i> <i class="kbnfont kbn-ban-message message" data-v-5775ee02></i> <i class="kbnfont kbn-ban-close close" data-v-5775ee02></i> <a target="_blank" href="https://vuepress-theme-reco.recoluan.com/views/plugins/kanbanniang.html" data-v-5775ee02><i class="kbnfont kbn-ban-info info" data-v-5775ee02></i></a> <i class="kbnfont kbn-ban-theme skin" style="display:none;" data-v-5775ee02></i></div> <canvas id="banniang" width="150" height="220" class="live2d" style="position:fixed;left:0px;bottom:0px;opacity:0.9;z-index:99999;" data-v-5775ee02></canvas></div> <div class="showBanNiang" style="display:none;" data-v-5775ee02>
    看板娘
  </div></div></div></div>
    <script src="/waw/assets/js/app.4506181e.js" defer></script><script src="/waw/assets/js/3.c812e0bc.js" defer></script><script src="/waw/assets/js/1.24e126b5.js" defer></script><script src="/waw/assets/js/14.1e185c4c.js" defer></script>
  </body>
</html>
